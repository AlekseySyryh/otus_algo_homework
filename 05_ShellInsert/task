Реализовать Insertion Sort и Shell Sort
Реализовать алгоритмы insertion sort и Shell sort. Дополнительно: протестировать работу алгоритмов на случайных массивах и на практически упорядоченных массивах, сравнить производительность. Сравнить производительнсоть сортировки Шелла c разной последовательностью шагов.

Как сравнивать производительность:

Для алгоритмов, как минимум, Insertion Sort, Shell Sort с двумя вариантами последовательностей шагов, сделать для каждого следующие измерения:

Создать массивы размера от 20, 40, 80, 160 ... и до~100.000 элементов для C++/Java или ~10.000 элементов в случае python. Для каждого размера сделать по три массива: случайный (функцией для shuffle из упорядоченного), массив, в котором перемешаны ~10% элементов, и массив, в котором перемешаны 5 элементов.

Замерять процессорное время для каждого алгоритма и каждого массива, составить табличку в формате .csv либо график, приложить к коду.

Варианты последовательностей "шагов" (gap sequences) Shell Sort можно брать отсюда, любые, но интереснее будет с O() < O(n^2): https://en.wikipedia.org/wiki/Shellsort#Gap_sequences
Критерии оценки: Дополнительно:
- реализован только один алгоритм сортировки / есть серьезные недочеты в реализации, влияющие на производительность - 1 балл
- алгоритмы реализованы корректно, но есть небольшие недочеты, влияющие на производительность - 2 балла (2 "основных" балла - необходимый минимум для зачета)
- оба алгоритма реализованы корректно - 3 балла

Дополнительно:
- проведено сравнение производительности на разных массивах - 1 балл
- проведено сравнение производительности Shell sort с разными последовательностями шагов - 1 балл