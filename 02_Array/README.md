# Затраты времени на 100000 операций, мс

Контейнер|Вставка начало|Вставка случайная|Вставка конец|Чтение начало|Чтение случайное|Чтение конец|Удаление начало|Удаление случайное|Удаление конец 
---|---:|---:|---:|---:|---:|---:|---:|---:|---:
singleArray|3981|5058|3502|0|0|0|4299|3448|3312
vectorArray|2335|1769|337|0|0|0|1923|1396|0
factorArray|2045|1483|1|0|0|0|1927|1389|1
matrixArray|13572|9326|8|1|1|1|14652|10156|1
spaceArray|13|2296|7310|0|1318|16213|3|4917|6923
linkedList|9|12183|15359|0|2411|37411|6|8736|17056
doubleLinkedList|10|15915|8|1|4864|0|7|8468|8
stlVector|2034|1482|0|0|1|0|1934|1396|0
stlDeque|1|797|1|0|0|0|2|803|2
stlForwardList|9|12248|16886|0|2860|34644|5|8304|31701
stlList|11|15541|9|1|4836|1|7|8515|7

#Комментарии

##singleArray

Простой массив.

Что про него можно сказать хорошего? Он простой и он занимает для хранения данных минимум памяти. Какк и все "настоящие" массивы имеет сложность доступа к произвольному элементу 0(1).

Минусы - любая вставка/удаление всегда приводит к перевыделению всей занятой памяти. С опреленного момента это становится долго и дорого (в прочем позже мы увидим что можно и хуже). 

##vectorArray

Работа над ошибками предыдущего варианта. Перевыделение памяти происходит не всегда, а только когда ее не хватает. В результате вставка/удаление просто копируют часть элементов в массиве. Особенно эффективна встака/удаление в/из конец массива - так копирование не нужно вовсе. 


##factorArray

Работа над ошибками предыдущего варианта. Память выделяется не фиксированными кусками, а пропрорционально уже выделенной. Это дает выигрыш при вставке на больших массивах. При удалении разницы нет.

Минус - в худшем случае до половины памяти может оказаться выделенной, но не использованной (а при удалении элементов даже больше).

Тем не менее именно этот алгоритм используется как "динамический массив по умолчанию" во многих языках.

##matrixArray

Попытка улучшить то, что уже хорошо, внезапно привела к провалу :) Вставка в начало массива все так-же приводит к куче копирований как в singleArray, но теперь копирование идет не одним большим куском, а кучей маленьких (неупорядоченных). В результате кэш на нас обижается и все становится совсем печально.

Плюс внезапно обращение к случайному элементу становится несколько медленее (хотя и все еще O(1)).

##spaceArray

Работа над ошибками предыдущего варианта. Вставка/удаление теперь приводят (в худшем случае) к копированию только текущего блока. Это хорошо. Но скорость поиска элемента по индексу теперь O(n) и это - ужасно. 

Теоретически результаты были бы лучше если бы мы могли вставлять удалять не по индексу, а по указателю, но API такой какой он есть.

В теории можно поискать компромисс - увеличение размера блока увеличит скорость поиска уменьшив скорость вставки/удаления и наоборот. Но стоит ли оно таких шаманств? 

##linkedList

Односвязный список.

Вставка любое место - O(1).

Вот только сложность поиска "этого места" - O(n).

Очень быстро вставлять/удалять первыую запись, но чем мы дальше от начала - тем дольше. Плюс не самая эффективная по памяти структура.

В принципе неплохо поджодит для реализации стека. 

##doubleLinkedList

Двусвязынй список. Работа над ошибками предыдущего варианта.

Вставка немного медленее (при вставке надо поменять не 2 указателя как раньше, а 4), зато быстро вставлять/читать можно не только с начала но и с конца.

В остальном все как в односвязном (только памяти расходует больше).

В принципе неплохо поджодит для реализации очереди и стека (но для стека односвязный списко предпочтительнее).

##stlVector

Оболчка над std::vector - реализации factorArray из стандартной библиотеки шаблонов. Быстродействие примерно такое-же.

##stlDeque

Оболчка над std::deque. У этой структуры нет прямого аналога с тем что мы делали. Больше всего она похожа на matrixArray, но если там неполным может быть только последний блок, то тут неполным может быть первый и последний (но не остальные).

В результате имеем эффективные чтения/вставки/удаления в начало и конец массива не особо теряя в доступе к произвольному элементу.

Именно на основе этого контейнера в stl по умолчанию реализуются структуры стек и очередь

##stlForwardList

Оболчка над std::forward_list. Это аналог нашего linkedList.

Из явных отличий - определение размера контейнера в STL не реализовано, потому подсчет размера имеет сложность O(N) (единственный алгоритм в этом списке). Конечно можно было бы сделать и O(1) как это делалось в других местах, но это уже было бы сильно жирно для оболочки :) 

Тесты в текущей реализации size() не используют в результате имеем примерно те-же показатели что и в linkedList.

##stlList

Оболочка над std::list. Это аналог нашего doubleLinkedList. Быстродействие примерно то-же.