# Merge sort

## Алгоритмы

Classic - обычный Mergesort

Insert - начиная с определенного размера применяется Insert Sort

Parallel split - то же что и insert, но split выполняется параллельно

Run - поддержка run (аля TimSort)

Run parallel merge - Run с параллельным merge

## Быстродействие алгоритмов на разных датасетах, мс

### Случайный массив

Элементов|Classic|Insert|Parallel split|Run|Run parallel merge
---|---|---|---|---|---
10|0|0|0|0|0
100|0|0|0|0|0
1000|0|0|0|0|0
10000|0|0|0|0|1
100000|9|7|4|8|8
1000000|100|88|45|92|79
10000000|1039|912|481|1017|1092

### В отстортированном массиве 5 пар элеметов поменяли местами

Элементов|Classic|Insert|Parallel split|Run|Run parallel merge
---|---|---|---|---|---
10|0|0|0|0|0
100|0|0|0|0|0
1000|0|0|0|0|0
10000|0|0|0|0|0
100000|3|1|1|0|0
1000000|32|23|13|7|8
10000000|340|267|155|47|45

### В отстортированном массиве 5 пар элеметов поменяли местами, затем массив развернули

Элементов|Classic|Insert|Parallel split|Run|Run parallel merge
---|---|---|---|---|---
10|0|0|0|0|0
100|0|0|0|0|0
1000|0|0|0|0|0
10000|0|0|0|0|0
100000|2|2|1|0|1
1000000|32|25|15|15|14
10000000|351|280|163|162|163

### В отстортированном массиве 10% пар элеметов поменяли местами

Элементов|Classic|Insert|Parallel split|Run|Run parallel merge
---|---|---|---|---|---
10|0|0|0|0|0
100|0|0|0|0|0
1000|0|0|0|0|0
10000|0|0|0|0|1
100000|4|2|2|2|3
1000000|34|25|15|16|16
10000000|341|269|157|181|180

### В отстортированном массиве 10% пар элеметов поменяли местами, затем массив развернули

Элементов|Classic|Insert|Parallel split|Run|Run parallel merge
---|---|---|---|---|---
10|0|0|0|0|0
100|0|0|0|0|0
1000|0|0|0|0|0
10000|0|0|0|0|1
100000|3|3|2|4|4
1000000|34|27|15|34|37
10000000|352|281|162|368|377

## Выводы:

1. По идее классический алгоритм не должен зависить от порядка элементов. Тем страннее, что эту связь мы наблюдаем. 
Возможно причина в каких-то оптимизациях компилятора (а-ля branch prediction).

1. Insert вполне ожидаемо быстрее классического. Особенно эффект заметем на частичо отсортироывнном массиве, 
что логично - insert sort хорош именно на таких массивах. Не вполне понятно почему массив в обратном порядке оказывает 
такой незначительный эффект. 

1. Распаралеливанин split дает вполне ожидаемое ускорение чуть меньше x2 (сказываются накладные расходы на распаралеливание)

1. Run ожидаемо очень хорош для частично упорядоченных массивов. Очень хорошо наблюдается эффект снижения быстродействия 
на развернутом массиве, а также по мере снжения упорядоченности.

1. Parallel run не дал особого эффекта. Видимо бутылочное горлышко у алгоритма не в операции merge которая распараллеливалась 
в тестах, а в операции split, но рапаралелить ее (а вернее поиск Runов) не представляется возможным.

